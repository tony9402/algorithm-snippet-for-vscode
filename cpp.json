{
    "Segment Tree With Lazy Propagation": {
        "prefix": [
            "seglazy",
            "segmentlazy"
        ],
        "body": [
            "template<typename T> struct SegmentLazy {",
            "    vector<T> tree;",
            "    vector<T> lazy;",
            "    int siz;",
            "    SegmentLazy(int N = 1 << 17) {",
            "        for(siz = 1; siz <= N; siz <<= 1);",
            "        tree.resize(siz << 1);",
            "        lazy.resize(siz << 1);",
            "    }",
            "    void propagate(int l, int r, int pos) {",
            "        if(!lazy[pos]) return;",
            "        if(l != r) {",
            "            lazy[pos << 1] = lazy[pos];",
            "            lazy[pos << 1 | 1] = lazy[pos];",
            "        }",
            "        tree[pos] = (r - l + 1) * lazy[pos];",
            "        lazy[pos] = 0;",
            "    }",
            "    void update(int l, int r, int s, int e, int pos, T data) {",
            "        if(s <= l && r <= e) {",
            "            lazy[pos] = data;",
            "            propagate(l, r, pos);",
            "            return;",
            "        }",
            "        propagate(l, r, pos);",
            "        if(e < l || r < s) return;",
            "        int mid = (l + r) / 2;",
            "        update(l, mid, s, e, pos << 1, data);",
            "        update(mid + 1, r, s, e, pos << 1 | 1, data);",
            "        tree[pos] = merge(tree[pos << 1], tree[pos << 1 | 1]);",
            "    }",
            "    void update(int s, int e, T data) { update(0, siz - 1, s, e, 1, data); }",
            "    T query(int l, int r, int s, int e, int pos) {",
            "        propagate(l, r, pos);",
            "        if(s <= l && r <= e) return tree[pos];",
            "        if(e < l || r < s) return T();",
            "        int mid = (l + r) / 2;",
            "        return merge(query(l, mid, s, e, pos << 1), query(mid + 1, r, s, e, pos << 1 | 1));",
            "    }",
            "    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }",
            "    T merge(T a, T b) { return a + b; }",
            "};"
        ],
        "description": "Segment Tree with Lazy Propagation"
    },
    "Fenwick Tree 1D": {
        "prefix": [
            "f1d",
            "fenwick"
        ],
        "body": [
            "template<typename T> struct Fenwick {",
            "    vector<T> tree;",
            "    int N;",
            "    Fenwick(int N):N(N) { tree.resize(N+1); }",
            "    void update(int idx, T data) {",
            "        for(int i = idx; i <= N; i += i & -i) tree[i] += data;",
            "    }",
            "    T query(int idx) {",
            "        T ret = 0;",
            "        for(int i = idx; i; i -= i & -i) ret += i;",
            "        return ret;",
            "    }",
            "    T query(int s, int e) { return query(e) - query(s - 1); }",
            "};"
        ],
        "description": "Fenwick Tree"
    },
    "Segment Tree": {
        "prefix": [
            "segtree",
            "seg"
        ],
        "body": [
            "template<typename T> struct Segment {",
            "    vector<T> tree;",
            "    int siz;",
            "    Segment(int N = 1 << 17) {",
            "        for(siz = 1; siz <= N; siz <<= 1);",
            "        tree.resize(siz << 1);",
            "    }",
            "    void update(int idx, T data) {",
            "        tree[idx += siz] = data;",
            "        while(idx >>= 1) tree[idx] = merge(tree[idx << 1], tree[idx << 1 | 1]);",
            "    }",
            "    T query(int l, int r, int s, int e, int pos) {",
            "        if(s <= l && r <= e) return tree[pos];",
            "        if(e < l || r < s) return 0;",
            "        int mid = (l + r) / 2;",
            "        return merge(query(l, mid, s, e, pos << 1), query(mid + 1, r, s, e, pos << 1 | 1));",
            "    }",
            "    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }",
            "    T merge(T a, T b) { return a + b; }",
            "};"
        ],
        "description": "Segment Tree"
    },
    "SuffixArray(Nlog^2N) (With LCP)": {
        "prefix": [
            "sa",
            "suffixarray"
        ],
        "body": [
            "template<typename T> struct SuffixArrayLCP { // O(Nlog^2N)",
            "    vector<int> sa, pos, tmp, lcp;",
            "    SuffixArray(const T& S) {",
            "        int N = (int)S.size();",
            "        sa = pos = tmp = vector<int>(N);",
            "        for(int i = 0; i < N; ++i) sa[i] = i, pos[i] = S[i];",
            "        for(int d = 1; ; d <<= 1) {",
            "            function<bool(int, int)> cmp = [&](int a, int b) -> bool {",
            "                if(pos[a] != pos[b]) return pos[a] < pos[b];",
            "                if(a + d < N && b + d < N) return pos[a + d] < pos[b + d];",
            "                return a > b;",
            "            };",
            "            sort(sa.begin(), sa.end(), cmp);",
            "            for(int i = 1; i < N; ++i) tmp[i] = tmp[i - 1] + cmp(sa[i - 1], sa[i]);",
            "            for(int i = 0; i < N; ++i) pos[sa[i]] = tmp[i];",
            "        }",
            "        buildLCP(S);",
            "    }",
            "    void buildLCP(const T& S) {",
            "        for(int i = 0, k = 0; i < N; ++i, k = max(0, k - 1)) {",
            "            while(sa[pos[i] - 1] + k < N && sa[pos[i]] + k < N && S[sa[pos[i] - 1] + k] == S[sa[pos[i]] + k]) ++k;",
            "            lcp[pos[i]] = k;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Suffix Array with LCP O(Nlog^2N)"
    },
    "Hashing": {
        "prefix": [
            "hashing"
        ],
        "body": [
            "template<long long C, long long HASH_MOD> struct Hashing {",
            "    vector<long long> H, B;",
            "    template<typename T> void build(const T& S) {",
            "        H.resize(S.size() + 1);",
            "        B.resize(S.size() + 1); B[0] = 1;",
            "        for(int i = 1; i <= (int)S.size(); ++i) H[i] = (H[i - 1] * C + S[i - 1]) % HASH_MOD;",
            "        for(int i = 1; i <= (int)S.size(); ++i) B[i] = B[i - 1] * C % HASH_MOD;",
            "    }",
            "    ll get(int s, int e) {",
            "        ll ret = (H[e] - H[s - 1] * B[e - s + 1]) % HASH_MOD;",
            "        if(ret < 0) ret += HASH_MOD;",
            "        return ret;",
            "    }",
            "    void chk_setting() { assert(gcd(C, HASH_MOD) == 1); }",
            "};"
        ],
        "description": "Hashing"
    },
    "a^b with modulo": {
        "prefix": [
            "power"
        ],
        "body": [
            "template<typename T> T power(T a, T b, T mod) {",
            "    if(b == 0) return 1;",
            "    if(b & 1) return a * power(a, b - 1, mod) % mod;",
            "    return power(a * a % mod, b >> 1, mod);",
            "}"
        ],
        "description": "a^b % mod"
    },
    "Testcase Basic Main": {
        "prefix": [
            "tcmain",
            "ma"
        ],
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(0);",
            "",
            "    int testcase = $1;$2 cin >> testcase;",
            "    while(~--testcase) {",
            "        $3",
            "    }",
            "}"
        ],
        "description": "Main Template for Testcase"
    },
    "fast input": {
        "prefix": [
            "fi",
            "fastinput"
        ],
        "body": [
            "#define BUFFERMAX 1 << 19",
            "struct IO {",
            "    char buf[BUFFERMAX];",
            "",
            "    char _read() {",
            "        static int idx = BUFFERMAX;",
            "        if(idx == BUFFERMAX){",
            "            fread(buf, 1, BUFFERMAX, stdin);",
            "            idx = 0;",
            "        }",
            "        return buf[idx++];",
            "    }",
            "",
            "    char readChar() {",
            "        char ret = _read();",
            "        while(ret == 10 || ret == 32) ret = _read();",
            "        return ret;",
            "    }",
            "",
            "    string readString() {",
            "        string ret = \\\"\\\";",
            "        char now = _read();",
            "        while(now == 10 || now == 32) now = _read();",
            "        while(true) {",
            "            ret += now;",
            "            now = _read();",
            "            if(now == 10 || now == 32) break;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    template<typename T> T readInt() {",
            "        T ret = 0;",
            "        bool minus = false;",
            "        char now = _read();",
            "        while(now == 10 || now == 32) now = _read();",
            "        if(now == \\'-\\') minus = true, now = _read();",
            "        while(48 <= now && now <= 57) {",
            "            ret = ret * 10 + now - 48;",
            "            now = _read();",
            "        }",
            "        if(minus) ret *= -1;",
            "        return ret;",
            "    }",
            "",
            "    void read(int &x) { x = readInt<int>(); }",
            "    void read(long long &x) { x = readInt<long long>(); }",
            "    void read(char &x) { x = readChar(); }",
            "    void read(string &x) { x = readString(); }",
            "    template<typename Type, typename... Types> void read(Type &arg, Types &...args) {  read(arg); read(args...); }",
            "} io;",
            "",
            "template<typename T>",
            "IO& operator>> (IO& in, T &x) { in.read(x); return in; }",
            "",
            "#define cin io",
            "#define istream IO"
        ],
        "description": "fast input"
    },
    "Value Compress": {
        "prefix": [
            "compress"
        ],
        "body": [
            "sort($TM_SELECTED_TEXT.begin(), $TM_SELECTED_TEXT.end());",
            "$TM_SELECTED_TEXT.erase(unique($TM_SELECTED_TEXT.begin(),$TM_SELECTED_TEXT.end()), $TM_SELECTED_TEXT.end());"
        ],
        "description": "Value Compress"
    },
    "range all": {
        "prefix": [
            "all"
        ],
        "body": [
            "$TM_SELECTED_TEXT.begin(), $TM_SELECTED_TEXT.end()"
        ],
        "description": "range all"
    },
    "Graph Basic Tempalte": {
        "prefix": [
            "graph"
        ],
        "body": [
            "template<typename T> struct Graph {",
            "    vector<vector<T>> G;",
            "    Graph(int N) { G.resize(N + 1); }",
            "    void addEdge(int u, T data) { G[u].emplace_back(data); }",
            "    int size() { return (int)G.size(); }",
            "    vector<T>& operator[](const int &idx) { return G[idx]; }",
            "};"
        ],
        "description": "Graph"
    }
}