{
    "Segment Tree With Lazy Propagation": {
        "prefix": [
            "seglazy",
            "segmentlazy"
        ],
        "body": [
            "template<typename T> struct SegmentLazy {",
            "    vector<T> tree;",
            "    vector<T> lazy;",
            "    int siz;",
            "    SegmentLazy(int N = 1 << 17) {",
            "        for(siz = 1; siz <= N; siz <<= 1);",
            "        tree.resize(siz << 1);",
            "        lazy.resize(siz << 1);",
            "    }",
            "    void propagate(int l, int r, int pos) {",
            "        if(!lazy[pos]) return;",
            "        if(l != r) {",
            "            lazy[pos << 1] += lazy[pos];",
            "            lazy[pos << 1 | 1] += lazy[pos];",
            "        }",
            "        tree[pos] += (r - l + 1) * lazy[pos];",
            "        lazy[pos] = 0;",
            "    }",
            "    void update(int l, int r, int s, int e, int pos, T data) {",
            "        if(s <= l && r <= e) {",
            "            lazy[pos] += data;",
            "            propagate(l, r, pos);",
            "            return;",
            "        }",
            "        propagate(l, r, pos);",
            "        if(e < l || r < s) return;",
            "        int mid = (l + r) / 2;",
            "        update(l, mid, s, e, pos << 1, data);",
            "        update(mid + 1, r, s, e, pos << 1 | 1, data);",
            "        tree[pos] = merge(tree[pos << 1], tree[pos << 1 | 1]);",
            "    }",
            "    void update(int s, int e, T data) { update(0, siz - 1, s, e, 1, data); }",
            "    T query(int l, int r, int s, int e, int pos) {",
            "        propagate(l, r, pos);",
            "        if(s <= l && r <= e) return tree[pos];",
            "        if(e < l || r < s) return T();",
            "        int mid = (l + r) / 2;",
            "        return merge(query(l, mid, s, e, pos << 1), query(mid + 1, r, s, e, pos << 1 | 1));",
            "    }",
            "    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }",
            "    T merge(T a, T b) { return a + b; }",
            "};"
        ],
        "description": "Segment Tree with Lazy Propagation"
    },
    "Heavy-Light Decomposition": {
        "prefix": [
            "hld",
            "heavy"
        ],
        "body": [
            "struct HLD {",
            "    Graph<int> G;",
            "    vector<int> par, top, dep, siz, in, out;",
            "    $1",
            "    int id;",
            "    HLD(Graph<int> G):G(G) {",
            "        int N = (int)G.size();",
            "        siz = par = top = dep = in = out = vector<int>(N);",
            "        id = 0;",
            "    }",
            "    void dfs(int cur=1, int prev=0) {",
            "        siz[cur] = 1;",
            "        par[cur] = prev;",
            "        dep[cur] = dep[prev] + 1;",
            "        for(int &nxt : G[cur]) {",
            "            if(nxt == prev) continue;",
            "            dfs(nxt, cur);",
            "            siz[cur] += siz[nxt];",
            "            if(siz[nxt] > siz[G[cur][0]]) swap(nxt, G[cur][0]);",
            "        }",
            "    }",
            "    void dfs2(int cur=1, int prev=0) {",
            "        in[cur] = ++id;",
            "        if(cur == 1) top[cur] = 1;",
            "        for(int nxt: G[cur]) {",
            "            if(nxt == prev)continue;",
            "            top[nxt] = (nxt == G[cur][0] ? top[cur] : nxt);",
            "            dfs2(nxt, cur);",
            "        }",
            "        out[cur] = id;",
            "    }",
            "    $2",
            "};"
        ],
        "description": "Heavy-Ligth Decomposition Query O(log^2N)"
    },
    "Union Find": {
        "prefix": [
            "uf",
            "unionfind"
        ],
        "body": [
            "struct UnionFind {",
            "    vector<int> uf, siz;",
            "    UnionFind(int N) {",
            "        uf.resize(N,-1);",
            "        siz.resize(N,1);",
            "    }",
            "    int find(int x) { return uf[x] < 0 ? x : uf[x] = find(uf[x]); }",
            "    bool merge(int a, int b) {",
            "        a = find(a); b = find(b);",
            "        if(a == b) return false;",
            "        uf[b] = a;",
            "        siz[a] += siz[b];",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "Union Find (No Rollback)"
    },
    "Fenwick Tree 1D": {
        "prefix": [
            "f1d",
            "fenwick"
        ],
        "body": [
            "template<typename T> struct Fenwick {",
            "    vector<T> tree;",
            "    int N;",
            "    Fenwick(int N):N(N) { tree.resize(N+1); }",
            "    void update(int idx, T data) {",
            "        for(int i = idx; i <= N; i += i & -i) tree[i] += data;",
            "    }",
            "    T query(int idx) {",
            "        T ret = 0;",
            "        for(int i = idx; i; i -= i & -i) ret += i;",
            "        return ret;",
            "    }",
            "    T query(int s, int e) { return query(e) - query(s - 1); }",
            "};"
        ],
        "description": "Fenwick Tree"
    },
    "Segment Tree": {
        "prefix": [
            "segtree",
            "seg"
        ],
        "body": [
            "template<typename T> struct Segment {",
            "    vector<T> tree;",
            "    int siz;",
            "    Segment(int N = 1 << 17) {",
            "        for(siz = 1; siz <= N; siz <<= 1);",
            "        tree.resize(siz << 1);",
            "    }",
            "    void update(int idx, T data) {",
            "        tree[idx += siz] = data;",
            "        while(idx >>= 1) tree[idx] = merge(tree[idx << 1], tree[idx << 1 | 1]);",
            "    }",
            "    T query(int l, int r, int s, int e, int pos) {",
            "        if(s <= l && r <= e) return tree[pos];",
            "        if(e < l || r < s) return 0;",
            "        int mid = (l + r) / 2;",
            "        return merge(query(l, mid, s, e, pos << 1), query(mid + 1, r, s, e, pos << 1 | 1));",
            "    }",
            "    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }",
            "    T merge(T a, T b) { return a + b; }",
            "};"
        ],
        "description": "Segment Tree"
    },
    "SuffixArray(Nlog^2N) (With LCP)": {
        "prefix": [
            "sa",
            "suffixarray"
        ],
        "body": [
            "template<typename T> struct SuffixArrayLCP { // O(Nlog^2N)",
            "    vector<int> sa, pos, tmp, lcp;",
            "    SuffixArray(const T& S) {",
            "        int N = (int)S.size();",
            "        sa = pos = tmp = vector<int>(N);",
            "        for(int i = 0; i < N; ++i) sa[i] = i, pos[i] = S[i];",
            "        for(int d = 1; ; d <<= 1) {",
            "            function<bool(int, int)> cmp = [&](int a, int b) -> bool {",
            "                if(pos[a] != pos[b]) return pos[a] < pos[b];",
            "                if(a + d < N && b + d < N) return pos[a + d] < pos[b + d];",
            "                return a > b;",
            "            };",
            "            sort(sa.begin(), sa.end(), cmp);",
            "            for(int i = 1; i < N; ++i) tmp[i] = tmp[i - 1] + cmp(sa[i - 1], sa[i]);",
            "            for(int i = 0; i < N; ++i) pos[sa[i]] = tmp[i];",
            "        }",
            "        buildLCP(S);",
            "    }",
            "    void buildLCP(const T& S) {",
            "        for(int i = 0, k = 0; i < N; ++i, k = max(0, k - 1)) {",
            "            while(sa[pos[i] - 1] + k < N && sa[pos[i]] + k < N && S[sa[pos[i] - 1] + k] == S[sa[pos[i]] + k]) ++k;",
            "            lcp[pos[i]] = k;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Suffix Array with LCP O(Nlog^2N)"
    },
    "KMP": {
        "prefix": [
            "kmp",
            "KMP"
        ],
        "body": [
            "template<typename T> struct KMP {",
            "    vector<int> fail;",
            "    vector<int> failure(const T &Q) {",
            "        fail.resize((int)Q.size() + 1);",
            "        for(int i = 1, j = 0; i < (int)Q.size(); ++i) {",
            "            while(j > 0 && Q[i] != Q[j]) j = fail[j - 1];",
            "            if(Q[i] == Q[j]) fail[i] = ++j;",
            "        }",
            "        return fail;",
            "    }",
            "    vector<int> kmp(const T& P, const T& Q) {",
            "        vector<int> res;",
            "        for(int i = 0, j = 0; i < (int)P.size(); ++i) {",
            "            while(j > 0 && P[i] != Q[j]) j = fail[j - 1];",
            "            if(P[i] == Q[j]) {",
            "                if(j + 1 == (int)Q.size()) res.push_back(i - (int)Q.size() + 1), j = fail[j];",
            "                else ++j;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "KMP O(|S| + |T|)"
    },
    "Hashing": {
        "prefix": [
            "hashing"
        ],
        "body": [
            "template<long long C, long long HASH_MOD> struct Hashing {",
            "    vector<long long> H, B;",
            "    template<typename T> void build(const T& S) {",
            "        H.resize(S.size() + 1);",
            "        B.resize(S.size() + 1); B[0] = 1;",
            "        for(int i = 1; i <= (int)S.size(); ++i) H[i] = (H[i - 1] * C + S[i - 1]) % HASH_MOD;",
            "        for(int i = 1; i <= (int)S.size(); ++i) B[i] = B[i - 1] * C % HASH_MOD;",
            "    }",
            "    ll get(int s, int e) {",
            "        ll ret = (H[e] - H[s - 1] * B[e - s + 1]) % HASH_MOD;",
            "        if(ret < 0) ret += HASH_MOD;",
            "        return ret;",
            "    }",
            "    void chk_setting() { assert(gcd(C, HASH_MOD) == 1); }",
            "};"
        ],
        "description": "Hashing"
    },
    "a^b with modulo": {
        "prefix": [
            "power"
        ],
        "body": [
            "template<typename T> T power(T a, T b, T mod=numeric_limits<T>::max()) {",
            "    if(b == 0) return 1;",
            "    if(b & 1) return a * power(a, b - 1, mod) % mod;",
            "    return power(a * a % mod, b >> 1, mod);",
            "}"
        ],
        "description": "a^b % mod"
    },
    "for [1, N]": {
        "prefix": [
            "f1i",
            "for1n"
        ],
        "body": [
            "for(int i = 1; i <= ($1); ++i) {",
            "    $2",
            "}"
        ],
        "description": "for [1, N]"
    },
    "Testcase Basic Main": {
        "prefix": [
            "tcmain",
            "ma"
        ],
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "typedef bool i1;",
            "typedef char i8;",
            "typedef short i16;",
            "typedef int i32;",
            "typedef long long i64;",
            "",
            "typedef unsigned char u8;",
            "typedef unsigned short u16;",
            "typedef unsigned int u32;",
            "typedef unsigned long long u64;",
            "",
            "typedef float f4;",
            "typedef double f8;",
            "typedef long double f16;",
            "",
            "template<typename T> using Vec = vector<T>;",
            "",
            "template<int fp=0> struct fastio { fastio() { ios::sync_with_stdio(false); cin.tie(0); if(fp)cout<<fixed<<' '<<setprecision(fp); } };",
            "",
            "template<typename First, typename Second> inline istream& operator>>(istream &in, pair<First, Second> &_data) { in>>_data.first>>_data.second; return in; }",
            "template<typename First, typename Second> inline ostream& operator<<(ostream &out, pair<First, Second> &_data) { out<<_data.first<<' '<<_data.second; return out; }",
            "template<typename First, typename Second, typename Third> inline istream& operator>>(istream &in, tuple<First, Second, Third> &_data) { in>>get<0>(_data)>>get<1>(_data)>>get<2>(_data); return in; }",
            "template<typename First, typename Second, typename Third> inline ostream& operator<<(ostream &out, tuple<First, Second, Third> &_data) { out<<get<0>(_data)<<' '<<get<1>(_data)<<' '<<get<2>(_data); return out; }",
            "",
            "template<typename InputType> void in(InputType& x) { cin>>x; }",
            "template<typename InputType, typename... InputTypes> void in(InputType& x, InputTypes& ...y) { cin>>x; in(y...); }",
            "template<typename IterableInputType> void vin(IterableInputType &V) { for(auto &x: V) cin >> x; }",
            "",
            "template<const int p=0, typename OutputType> void out(OutputType x) { cout<<x<<' '; }",
            "template<const int p=0, typename OutputType, typename... OutputTypes> void out(OutputType x, OutputTypes ...y) { cout<<fixed<<setprecision(p)<<x<<' '; out<p>(y...); }",
            "template<const int p=0, typename IterableOutputType> void vout(const IterableOutputType &V) { for(auto &x: V) out<p>(x); }",
            "",
            "template<i64 modulo=numeric_limits<i64>::max(), typename... T> i64 Sum(T... x) { return (... + x) % modulo; }",
            "template<i64 modulo=numeric_limits<i64>::max(), typename... T> i64 Mul(T... x) { return (... * x) % modulo; }",
            "",
            "constexpr int dy[] = {-1,1,0,0,-1,-1,1,1,-2,-1,1,2,2,1,-1,-2};",
            "constexpr int dx[] = {0,0,-1,1,-1,1,-1,1,1,2,2,1,-1,-2,-2,-1}",
            "",
            "int main() {",
            "    fastio();",
            "",
            "    int testcase = $1;$2 cin >> testcase;",
            "    while(~--testcase) {",
            "        $3",
            "    }",
            "}"
        ],
        "description": "Main Template for Testcase"
    },
    "for [0, N)": {
        "prefix": [
            "f0i",
            "for0n"
        ],
        "body": [
            "for(int i = 0; i < ($1); ++i) {",
            "    $2",
            "}"
        ],
        "description": "for [0, N)"
    },
    "fast input": {
        "prefix": [
            "fi",
            "fastinput"
        ],
        "body": [
            "#define BUFFERMAX 1 << 19",
            "struct IO {",
            "    char buf[BUFFERMAX];",
            "",
            "    char _read() {",
            "        static int idx = BUFFERMAX;",
            "        if(idx == BUFFERMAX){",
            "            fread(buf, 1, BUFFERMAX, stdin);",
            "            idx = 0;",
            "        }",
            "        return buf[idx++];",
            "    }",
            "",
            "    char readChar() {",
            "        char ret = _read();",
            "        while(ret == 10 || ret == 32) ret = _read();",
            "        return ret;",
            "    }",
            "",
            "    string readString() {",
            "        string ret = \"\";",
            "        char now = _read();",
            "        while(now == 10 || now == 32) now = _read();",
            "        while(true) {",
            "            ret += now;",
            "            now = _read();",
            "            if(now == 10 || now == 32) break;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    template<typename T> T readInt() {",
            "        T ret = 0;",
            "        bool minus = false;",
            "        char now = _read();",
            "        while(now == 10 || now == 32) now = _read();",
            "        if(now == '-') minus = true, now = _read();",
            "        while(48 <= now && now <= 57) {",
            "            ret = ret * 10 + now - 48;",
            "            now = _read();",
            "        }",
            "        if(minus) ret *= -1;",
            "        return ret;",
            "    }",
            "",
            "    void read(int &x) { x = readInt<int>(); }",
            "    void read(long long &x) { x = readInt<long long>(); }",
            "    void read(char &x) { x = readChar(); }",
            "    void read(string &x) { x = readString(); }",
            "    template<typename Type, typename... Types> void read(Type &arg, Types &...args) {  read(arg); read(args...); }",
            "} io;",
            "",
            "template<typename T>",
            "IO& operator>> (IO& in, T &x) { in.read(x); return in; }",
            "",
            "#define cin io",
            "#define istream IO"
        ],
        "description": "fast input"
    },
    "Value Compress": {
        "prefix": [
            "compress"
        ],
        "body": [
            "sort($1.begin(), $1.end());",
            "$1.erase(unique($1.begin(),$1.end()), $1.end());"
        ],
        "description": "Value Compress"
    },
    "range all": {
        "prefix": [
            "all"
        ],
        "body": [
            "$1.begin(), $1.end()"
        ],
        "description": "range all"
    },
    "Floyd with Traceback": {
        "prefix": [
            "floyd"
        ],
        "body": [
            "template<typename T> struct Floyd {",
            "    const T INF = numeric_limits<T>::max() / 2;",
            "    vector<vector<T>> DP;",
            "    vector<vector<int>> path;",
            "    int N;",
            "    Floyd(int N):N(N) {",
            "        DP = vector<vector<T>>(N, vector<T>(N, INF));",
            "        path = vector<vector<int>>(N, vector<int>(N, -1));",
            "        for(int i=0;i<N;++i) DP[i][i]=0;",
            "    }",
            "    void addEdge(int u, int v, int w) { DP[u][v] = min(DP[u][v], w); }",
            "    void floyd() {",
            "        for(int k = 0; k < N; ++k) {",
            "            for(int i = 0; i < N; ++i) {",
            "                for(int j = 0; j < N; ++j) {",
            "                    if(DP[i][j] > DP[i][k] + DP[k][j]) {",
            "                        DP[i][j] = DP[i][k] + DP[k][j];",
            "                        path[i][j] = k;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "    vector<int> getPath(int S, int E) {",
            "        vector<int> ret;",
            "        if(S==E || DP[S][E] == INF)return ret;",
            "        function<void(int,int)> findPath = [&](int s, int e) -> void {",
            "            int pre = path[s][e];",
            "            if(!~pre) return;",
            "            findPath(s,pre);",
            "            ret.push_back(pre);",
            "            findPath(pre,e);",
            "        };",
            "        ret.push_back(S);",
            "        findPath(S, E);",
            "        ret.push_back(E);",
            "        return ret;",
            "    }",
            "    vector<T>& operator[](const int &idx) { return DP[idx]; }",
            "};"
        ],
        "description": "Floyd O(N^3) with Traceback"
    },
    "Graph Basic Tempalte": {
        "prefix": [
            "graph"
        ],
        "body": [
            "template<typename T> struct Graph {",
            "    vector<vector<T>> G;",
            "    Graph(int N) { G.resize(N + 1); }",
            "    void addEdge(int u, T data) { G[u].emplace_back(data); }",
            "    int size() { return (int)G.size(); }",
            "    vector<T>& operator[](const int &idx) { return G[idx]; }",
            "};"
        ],
        "description": "Graph"
    },
    "Dijkstra": {
        "prefix": [
            "dijk",
            "dijkstra"
        ],
        "body": [
            "template<typename T> struct Dijkstra {",
            "    const T INF = numeric_limits<T>::max();",
            "    Graph<pair<int, T>> G;",
            "    int N;",
            "    Dijkstra(Graph<pair<int, T>> G):G(G) { N = (int)G.size(); }",
            "    vector<T> dijkstra(int S) {",
            "        vector<T> dist(N, INF);",
            "        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> pq;",
            "        pq.emplace(dist[S] = 0, S);",
            "        while(!pq.empty()) {",
            "            auto [d, cur] = pq.top(); pq.pop();",
            "            if(dist[cur] != d) continue;",
            "            for(auto [nxt, w] : G[cur]) {",
            "                if(dist[nxt] > dist[cur] + w) {",
            "                    dist[nxt] = dist[cur] + w;",
            "                    pq.emplace(dist[nxt], nxt);",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "};"
        ],
        "description": "Dijkstra"
    }
}